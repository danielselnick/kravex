use anyhow::Result;
use async_trait::async_trait;

use crate::backends::{elasticsearch, file, in_mem};

/// ðŸ•³ï¸ A sink that sends pre-rendered payloads â€” pure I/O, zero logic.
///
/// The yin to the source's yang. The drain at the bottom of the pipeline tub.
/// Sinks are ONLY an abstraction for how to send the request â€” HTTP POST to /_bulk,
/// write to file, stash in memory. They do not buffer. They do not transform.
/// They receive the full rendered payload and send it. Like a postal worker who
/// delivers the mail without reading it. (Unlike your actual postal worker, Kevin.)
///
/// # Contract ðŸ“œ
/// - `send` accepts a fully rendered payload string and writes/sends it. That's it.
/// - `close` flushes, finalizes, and bids the data a fond farewell. MUST be called.
///   Skipping `close` is a bug. It is also considered rude.
/// - Buffering, transforming, and binary collecting happen in the SinkWorker, NOT here.
///
/// # Knowledge Graph ðŸ§ 
/// - Pattern: trait â†’ concrete impls (FileSink, InMemorySink, ElasticsearchSink) â†’ SinkBackend enum
/// - SinkWorker does: transform â†’ buffer â†’ binary collect â†’ call sink.send(payload)
/// - Sink does: I/O. Just I/O. HTTP POST, file write, memory push. Nothing else.
/// - Ancient proverb: "He who puts business logic in the Sink, debugs in production."
#[async_trait]
pub(crate) trait Sink: std::fmt::Debug {
    /// ðŸ“¡ Send a fully rendered payload to the destination. I/O only. No questions asked.
    async fn send(&mut self, payload: String) -> Result<()>;
    /// ðŸ—‘ï¸ Flush, finalize, and release. Call this. Always. No exceptions. Not even on Fridays.
    async fn close(&mut self) -> Result<()>;
}

/// ðŸŽ­ The many faces of a Sink â€” a polymorphic casting call for data destinations.
///
/// Mirrors `SourceBackend` on the other end of the pipeline. Whoever designed this
/// was clearly a fan of symmetry. Or they ran out of ideas. Hard to tell.
///
/// The enum dispatches `receive` and `close` to the inner concrete type,
/// keeping the supervisor blissfully ignorant of where data actually lands.
/// Ignorance is a feature. It's called "abstraction." We put it in AGENTS.md.
#[derive(Debug)]
pub(crate) enum SinkBackend {
    InMemory(in_mem::InMemorySink),
    File(file::FileSink),
    Elasticsearch(elasticsearch::ElasticsearchSink),
}

#[async_trait]
impl Sink for SinkBackend {
    async fn send(&mut self, payload: String) -> Result<()> {
        match self {
            SinkBackend::InMemory(sink) => sink.send(payload).await,
            SinkBackend::File(sink) => sink.send(payload).await,
            SinkBackend::Elasticsearch(sink) => sink.send(payload).await,
        }
    }

    async fn close(&mut self) -> Result<()> {
        match self {
            SinkBackend::InMemory(sink) => sink.close().await,
            SinkBackend::File(sink) => sink.close().await,
            SinkBackend::Elasticsearch(sink) => sink.close().await,
        }
    }
}
